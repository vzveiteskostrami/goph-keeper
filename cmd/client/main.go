/*
   Дисклеймер.
   Клиентская часть системы зашифрованного хранения критически важной информации.
   Клиент представляет из себя исполняемый модуль, реализованый в CLI интерфейсе
   максимально френдли, насколько это возможно для данного интерфейса.
   Для старта достаточно разместить клиентское приложение (для Windows это client.exe)
   в желаемой директории (например, c:\cii) и запустить его без параметров. В этом случае
   будет предложено интерактивно создать файл конфигурации config.json. Не возбраняется
   разместить конфигурационный файл заранее рядом с исполняемым модулем. В этом случае
   диалога по созданию файла конфигурации не будет. В конфигурационном файле на данный
   момент два параметра:
   Постоянный логин. Не обязательный параметр. Удобно задать, если предполагается один
   пользователь на компьютере. Это позволит не вводить логин тем или иным способом при
   каждом использовании. Если пользователей приложения на компьютере много, всё начинает
   зависеть от интенсивности использования разными пользователями приложения. Если кто-то
   один использует часто, а все остальные редко, имеет смысл задать логин в конфигурации.
   Если все используют примерно одинаково, перманентный логин лучше не задавать.
   URL и порт сервера хранения информации. Обязательный параметр. Без серверной части
   приложение не может стартовать с нуля, так как все регистрации новых пользователей
   проводятся строго на сервере. А не зарегистрированный пользователь не сможет
   авторизоваться в системе даже для локальной работы.

   Принципы работы.
   У клиента есть только одна обязательная опция командной строки:
     -o <название выполняемой операции>

   Например, это может выглядеть так:
     c:\ii>client -o list
     c:\ii>client -o registration

   Все остальные параметры командной строки являются опциональными и работают по принципу,
   если необходимая для выполняемой операции опция опция НЕ введена в командной строке,
   она запрашивается интерактивно у пользователя во время исполнения. Все опции, которые
   введены, но не используются в выполняемой операции, игнорируются.
   Например, если вы хотите зарегистрироваться, но не хотите ничего вводить интерактивно,
   необходимо указать все требуемые параметры (а в данном случае это логин и пассворд) в
   командной строке:
     c:\ii>client -o registration -l "Ньютон Исаак" -p grAVITy1642

   Если данный логин никем не занят на сервере, регистрация не потребует от вас больше
   никакого ввода.

   Набор выполняемых операций.
   Операции вводятся в командной строке с помощью флага -o <название выполняемой операции>.
    Доступные на данный момент операции:
     registration - регистрация нового пользователя
     session      - создание\закрытие сессии для пользователя
	 new          - добавление новой сущности в локальное хранилище
     set          - изменение данных хранимой сущности в локальном хранилище
	 get          - получение данных хранимой сущности в читаемом виде
	 delete       - удаление сущности из локального хранилища
	 rename       - переименование сущности
	 list         - получить список хранимых сущностей
	 sync         - произвести синхронизацию данных с сервером

    Регистрация (registration).
     Имеет параметры:
	  -l <логин>  - желаемый логин
	  -p <пароль> - желаемый пароль
	  Пример:
	    c:\ii>client -o registration -l Буратино -p tri_korochki_hleba

    Сессия (session).
     Имеет параметры:
	  -l  <логин>              - логин авторизирующегося пользователя
	  -p  <пароль>             - пароль авторизирующегося пользователя
	  -du <продолжительность>  - продолжительность сессии в минутах. От 1 минуты до 5 лет
      -both                    - флаг без уточнений, указывающий, что надо авторизоваться
	                             и локально, и на сервере
	  -local                   - флаг без уточнений, указывающий, что нам нужна сессия
	                             только для локального хранилища. Имеет смысл использовать
								 именно его, если в данной сессии не предполагается
								 синхронизация с сервером
	  -close                   - флаг без уточнений, указывающий, что надо принудительно
	                             закрыть сессию
	  Пример:
	    c:\ii>client -o session -l Буратино -p tri_korochki_hleba -du 60 -local
	    c:\ii>client -o session -l Буратино -p tri_korochki_hleba -du 1 -both
	    c:\ii>client -o session -close

    Добавление новой сущности в локальное хранилище (new).
	 Имеет общие параметры:
	  -e    <тип>          - тип вводимой сущности. Допустимые значения:
	                            pass - ввод пары логин/пароль для сохранения
				                card - хранимые данные банковской карты
				                txt  - хранить текстовую информацию
				                bin  - хранить бинарные данные. Фактически закачать в хранилище файл
	  -n    <имя сущности> - имя сохраняемой сущности. Фактически, локальный идентификатор
	  -note <текст>        - пояснительный текст к сущности. Может, какой-то URL и тд

	  Дальнейшие параметры зависят от типа вводимой сущности.
       Тип сущности pass:
		 -wl <логин>  - сохраняемый логин
		 -wp <пароль> - сохраняемый пароль

       Тип сущности card:
		 -num <номер>     - номер карты в любом удобном виде
		 -exp <месяц/год> - месяц/год истечения срока действия карты
		 -hol <владелец>  - кто указан владельцем карты
		 -cvv <сививи>    - обратная сторона карты, так интересующая мошенников

       Тип сущности txt:
		 -t <текст> - сохраняемый текст

       Тип сущности bin:
		 -f <имя файла> - имя сохраняемого в локальное хранилище файла
	  Пример:
	    c:\ii>client -o new -e pass -n "Логон Мальвины на вход в онлайн казино" -wl Мальвина -wp devochka_s_golubymi_volosami
	    c:\ii>client -o new -e card -n "Карта Пьеро в Сбере" -num "1111 2222 3333 4444" -cvv 234 -exp "01/44" -hol "Мальдини Пьеро"
	    c:\ii>client -o new -e txt -n "Толстой. Война и мир" -t "Смеркалось. На улице шёл дождь и рота красноармейцев."
	    c:\ii>client -o new -e bin -n "Фото, где я голый" -f "c:\documents\imnaked.jpg" -note "Никогда больше так не надо"

    Удаление хранимой сущности (delete).
     Имеет параметры:
	  -n <название> - название удаляемой хранимой сущности
	  Пример:
	    c:\ii>client -o delete -n "Логон Мальвины на вход в онлайн казино"

    Получение хранимой сущности в читаемом виде (get).
     Имеет параметры:
	  -n <название> - название получаемой хранимой сущности
	  Пример:
	    c:\ii>client -o get -n "Толстой. Война и мир"

    Переименование хранимой сущности (rename).
     Имеет параметры:
	  -n  <название> - название переименовываемой сущности
	  -nn <название> - новое название хранимой сущности
	  Пример:
	    c:\ii>client -o rename -n "Толстой. Война и мир" -nn "Горький. На дне"

    Изменение данных сущности в локальном хранилище (set).
	 Имеет общие параметры:
	  -n    <имя сущности> - имя изменяемой сущности. Фактически, локальный идентификатор
	  -note <текст>        - пояснительный текст к сущности. Может, какой-то URL и тд

	  Дальнейшие параметры зависят от типа сущности, данные которой меняют.
       Тип сущности pass:
		 -wl <логин>  - сохраняемый логин
		 -wp <пароль> - сохраняемый пароль

       Тип сущности card:
		 -num <номер>     - номер карты в любом удобном виде
		 -exp <месяц/год> - месяц/год истечения срока действия карты
		 -hol <владелец>  - кто указан владельцем карты
		 -cvv <сививи>    - обратная сторона карты, так интересующая мошенников

       Тип сущности txt:
		 -t <текст> - сохраняемый текст

       Тип сущности bin:
		 -f <имя файла> - имя сохраняемого в локальное хранилище файла
	  Пример:
	    c:\ii>client -o set -e pass -n "Логон Мальвины на вход в онлайн казино" -wl Мальвина -wp devochka_s_golubymi_volosami
	    c:\ii>client -o set -e card -n "Карта Пьеро в Сбере" -num "1111 2222 3333 4444" -cvv 234 -exp "01/44" -hol "Мальдини Пьеро"
	    c:\ii>client -o set -e txt -n "Толстой. Война и мир" -t "Смеркалось. На улице шёл дождь и рота красноармейцев."
	    c:\ii>client -o set -e bin -n "Фото, где я голый" -f "c:\documents\imnaked.jpg" -note "Никогда больше так не надо"

	Получение списка хранимых сущностей (list).
     Имеет параметры:
	  -e     <тип сущности> - выводить только сущности указанного типа
	  -n     <наименование> - выводить только сущности, в наименовании которых встречается
	                          указанный текст
	  -brief                - флаг без уточнений, указывающий, что нам достаточно краткой
	                          информации о сущностях
	  Пример:
	    c:\ii>client -o list
	    c:\ii>client -o list -e pass
	    c:\ii>client -o list -e card -n "сбер"

    Синхронизация данных с сервером (sync).
	 Синхронизация выполняет следующие операции:
	    1) Выгрузка новых сущностей на сервер.
	    2) Обновление изменённых сущностей на сервере.
		3) Загрузка появившихся на сервере новых сущностей в локальное хранилище.
		4) Загрузка изменившихся на сервере сущностей в локальное хранилище.
		5) Удаление на сервере сущностей, уже удалённых из локального хранилица.
		6) Удаление из локального хранилища сущностей, удалённых с сервера.
		7) Отслеживание конфликтов корректировки данных.
    В общем случае запускается без параметров.
	  client -o sync
	  при таких параметрах в одном запуске клиента будут выполнены все приведённые
	  выше операции.
	  При использовании параметра -n <имя сущности> будет проведена синхронизация
	  только указанной сущности. Доступны операции обновления и записи новых данных.
	  Не распространяется на удаление.
	  client -o sync -n "Секретный пароль"
	  Будут синхронизированы данные только сущности "Секретный пароль".
	  Обычно такое поведение не требуется, режим сделан не для одиночной синхронизации,
	  а для разрешения конфликтов. Просто его можно использовать в качестве одиночной
	  синхронизации, но особого смысла в такой операции нет.
      В случае разрешения конфликта необходимо воспользоваться флагом -strict.
	  Флаг -strict имеет два возможных значения:
         -strict read  - исчерпать конфликт, загрузив данные сущности с сервера
		                 в локальное хранилище.
		 -strict write - исчерпать конфликт, загрузив данные сущности из локального
		                 хранилища на сервер.
	  Флаг -strict без указания имени сущности игнорируется, будет выполнена обыкновенная
	  операция синхронизации.
	  Пример:
	    c:\ii>client -o sync
		c:\ii>client -o sync -n "Данные карты Сбер" -strict read
		c:\ii>client -o sync -n "Данные карты Альфа-банк" -strict write
*/

package main

import (
	"fmt"

	"github.com/vzveiteskostrami/goph-keeper/internal/client/chttp"
	"github.com/vzveiteskostrami/goph-keeper/internal/client/config"
	"github.com/vzveiteskostrami/goph-keeper/internal/client/oper"
	"github.com/vzveiteskostrami/goph-keeper/internal/co"
)

func main() {
	if err := config.ReadData(); err != nil {
		fmt.Println("Ошибка чтения конфигурации:", err)
		return
	}

	cfg := config.Get()

	if cfg.Operation == nil || *cfg.Operation == "" {
		fmt.Println("Не указана операция \"-o=<operation>\"")
		oper.SaveLastOperationDateTime()
		return
	}

	// Для отлова хитрожопых, которые поменяют системное время и таким образом
	// захотят продлить время работы чужого локального токена вспять.
	// Если это регистрация или новая сессия, то пофиг. А вот если какие-то
	// операции с данными, то надо проверить, что текущее время строго больше
	// времени последней проведённой операции.
	if !(*cfg.Operation == "registration" ||
		*cfg.Operation == "session") {
		if !oper.CheckLastOperationDateTime() {
			return
		}
	}

	// Если операция требует обращения к серверу, сначала просто проверим его
	// наличие в системе. Если его нет, то и затевать ничего не надо.
	if *cfg.Operation == "registration" ||
		(*cfg.Operation == "session" && *cfg.Place == co.SessionBoth) ||
		*cfg.Operation == "sync" {
		err := chttp.CheckServerPresent()
		if err != nil {
			fmt.Println("Сервер неработоспособен. Операция в данный момент невозможна.")
			fmt.Println("Попробуйте выполнить операцию позднее.")
			fmt.Println("При проверке сервера произошла ошибка:")
			fmt.Println(err)
			oper.SaveLastOperationDateTime()
			return
		}
	}

	sessionOwner := ""
	// Если операция требует наличия локальной сессии, проверим, что она открыта и
	// не истекла.
	if *cfg.Operation == "get" ||
		*cfg.Operation == "set" ||
		*cfg.Operation == "rename" ||
		*cfg.Operation == "list" ||
		*cfg.Operation == "sync" ||
		*cfg.Operation == "delete" ||
		*cfg.Operation == "new" {
		var err error
		sessionOwner, err = oper.CheckLocalSession()
		if err != nil {
			fmt.Println("Неудачная проверка локальной сессии:")
			fmt.Println(err)
			oper.SaveLastOperationDateTime()
			return
		} else {
			fmt.Println("Владелец сессии", sessionOwner)
		}
	}

	if *cfg.Operation == "registration" {
		oper.Registration(*cfg.Login, *cfg.Password)
	} else if *cfg.Operation == "session" && *cfg.Place == co.SessionClose {
		oper.CloseSession()
	} else if *cfg.Operation == "session" {
		oper.Authorization(*cfg.Login, *cfg.Password, *cfg.Place, *cfg.SessionDuration)
	} else if *cfg.Operation == "list" {
		oper.ShowEntityList(sessionOwner, *cfg.Brief, *cfg.EntityKind, *cfg.EntityName)
	} else if *cfg.Operation == "new" {
		oper.NewEntity(sessionOwner,
			*cfg.EntityKind,
			*cfg.EntityName,
			*cfg.WriteLogin,
			*cfg.WritePassword,
			*cfg.Number,
			*cfg.Expired,
			*cfg.Holder,
			*cfg.Cvv,
			*cfg.Note,
			*cfg.WriteFile,
			*cfg.Text)
	} else if *cfg.Operation == "rename" {
		oper.RenameEntity(sessionOwner,
			*cfg.EntityName,
			*cfg.EntityNewName)
	} else if *cfg.Operation == "set" {
		oper.SetEntity(sessionOwner,
			*cfg.EntityName,
			*cfg.WriteLogin,
			*cfg.WritePassword,
			*cfg.Number,
			*cfg.Expired,
			*cfg.Holder,
			*cfg.Cvv,
			*cfg.Note,
			*cfg.WriteFile,
			*cfg.Text)
	} else if *cfg.Operation == "delete" {
		oper.DeleteEntity(sessionOwner, *cfg.EntityName)
	} else if *cfg.Operation == "get" {
		oper.GetEntity(sessionOwner, *cfg.EntityName)
	} else if *cfg.Operation == "sync" {
		oper.Syncronize(sessionOwner, *cfg.EntityName, *cfg.Strict)
	} else {
		fmt.Println("Не опознана операция " + *cfg.Operation)
	}
	oper.SaveLastOperationDateTime()
}
